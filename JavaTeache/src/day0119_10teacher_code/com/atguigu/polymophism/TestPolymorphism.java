package day0119_10teacher_code.com.atguigu.polymophism;

/*
6.3 面向对象的基本特征之三：多态
1、多态能解决什么问题？

场景1：同一个数组希望它既可以存储学生对象、教师对象、其他员工对象
场景2：给某个类设计成员变量时，只知道它属于某个系列的类型，但是具体是哪个类型不清楚
class Husband{//Husband丈夫
    private String name;
    private Wife lover ;
}

Wife的类型可以是一个Person，Robot（机器人），Demon（妖）

场景3：在设计一个方法的形参、返回值类型时，可以确定它是某个系列的类型，但是不能确定具体是哪个类型
public void compareArea(图形类型 g1, 图形类型  g2)
图形类型：可能是矩形、圆、三角形...

问题：可以确定某个变量、元素等它的类型是属于某个系列的，但是不能确定它更具体的类型。
这个变量需要赋值的对象可能是这个系列的子类的任意一种对象。
那么就需要多态这种特性支持。

2、什么是多态？
（1）多态引用的概念
父类类型 变量 = 子类的对象;

（2）多态的现象
编译时类型和运行时类型不一致。
编译时，这个变量是“父类”的类型。它可以，也只能调用父类中声明的方法。
运行时，这个变量是“子类”的类型。所以它会执行子类重写的方法体。
子类重写了父类的方法，通过父类的变量调用重写的方法时，执行的是子类重写后的代码。
子类如果没有重写这个方法，还是执行父类中实现的方法体。

对象的本质类型是子类的类型，只是编译器在编译时，把它看成父类的类型，
或者把它当成父类的类型来“检查”。

3、多态的好处：代码更灵活的，功能更强大了。

4、应用的场景
（1）多态数组
元素的类型声明为父类的类型，元素实际存储的是子类对象
（2）多态参数
形参的类型是父类的类型，实参对象是子类对象
（3）多态返回值
方法的返回值类型写的是父类类型，实际返回的是子类对象
（4）变量的类型是父类的类型，变量的值是子类的对象

编译时看父类，运行时看子类。“重写的方法”
 */
public class TestPolymorphism {
    public static void main(String[] args) {
        Person p = new Person();
        Pet dog = new Dog();
        p.adopt(dog);//dog是实参，它的类型是Pet
//        p.feed();

        Pet cat = new Cat();
        p.adopt(cat);
        p.feed();

        System.out.println("---------------------");
        Pet pet = new Dog();
        pet.eat();//因为Pet类中有eat()方法
//        pet.watchHouse();//编译报错，因为Pet类中没有watchHouse方法
    }
}
