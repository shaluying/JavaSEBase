package 面向对象中.继承02.子类调用父类成员及重写02;

/*
智能手机子类，关于来电显示号码这个功能有改进，不仅仅显示号码，
还可以显示头像，姓名/来电地区等
 */

/*
在继承的时候，子类会继承父类所有的成员变量（实例变量）和成员方法（实例方法）。
既然可以继承，
(1)在子类外面
只要权限修饰符允许，通过子类对象可以直接使用父类中声明的成员变量（实例变量）和成员方法（实例方法）
------------------(2)在子类里面
只要权限修饰符允许，可以直接使用父类中声明的成员变量（实例变量）和成员方法（实例方法）
不需要通过“对象.”的方式来引用
 */

/*
1、方法的重写（Override）
当子类对从父类继承的方法实现（方法体）不满意时，
或者说，子类对某个方法的实现有更进一步的改良，
子类完全可以重写/覆写这个方法。

2、IDEA中如何重写父类的某个方法呢？
光标定位在子类要写方法的位置，按快捷键。
快捷键：Ctrl + O

3、当通过子类对象调用重写的方法时，肯定是执行重写后的代码。

4、当在子类重写方法的方法体中，想要继续执行
父类被重写方法的方法体时，
可以通过“super.父类被重写方法名(..)"

5、重写方法有要求：
（1）方法名：必须相同
（2）形参列表：必须相同
（3）返回值类型：
    基本数据类型和void，必须相同
    引用数据类型：<=
           Java中的子类<父类，这个是从类表示的事物范围角度来说的。

子类重写的方法的返回值类型可以和父类被重写方法的返回值类型一样。
子类重写的方法的返回值类型可以是父类被重写方法的返回值类型的子类。
（4）权限修饰符：
首先，子类要重写父类的某个方法，要求该方法必须在子类是可见。
意味着的private的方法，在子类是不能被重写。
跨包的子类，权限修饰符缺省的方法，在子类中也是不能被重写。

其次，子类重写父类的方法时，权限修饰符必须满足>=的关系

（5）其他要求，等待后面补充
其他修饰符：static,final等
抛出的异常类型等。


对比方法的重载：
    方法名：必须相同
    形参列表：必须不同
    返回值类型：无关

6、重写方法上面强烈建议保留 @Override
这个是用于注释，标记，该方式是子类重写父类的方法，不是子类自己扩展的方法
如果去掉@Override，对于代码执行来说，没有任何影响，但是会影响一些代码的编译检查。
在重写的方法上面保留@Override，可以让编译器帮你检查是否满足重写的种种要求。
 */

public class SmartPhone extends Phone {

    public void showFunction() {
        sendMessage(); // 调用了父类的方法
        call();  // 调用了父类的方法
        showNumber();  // 调用了自己重写的父类方法
    }

    @Override
    public void showNumber() {
        //重写的意思，就是重新实现这个方法，就是重新编写方法体
        System.out.println("显示头像");
        System.out.println("显示名称等");

        //想要继续保留父类被重写的功能：显示来电号码
        super.showNumber();
    }

    //这个是用于注释，标记，该方式是子类重写父类的方法，不是子类自己扩展的方法
    //如果去掉@Override，对于代码执行来说，没有任何影响，但是会影响一些代码的编译
    //在重写的方法上面保留@Override，可以让编译器帮你检查是否满足重写的种种要求。
    @Override
    public SmartPhone getOwner() {
        return new SmartPhone();
    }

    public String getInfo() {
        return "手机名称：" + name + "，价格：" + getPrice();
    }
}
